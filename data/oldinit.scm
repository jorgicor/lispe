(define else #t)

(define (null? p)
  (eq? p '()))

(define (zero? n)
  (eqv? n 0))

(define (positive? n)
  (> n 0))

(define (negative? n)
  (< n 0))

(define (not b)
  (eq? b #f))

(define (boolean? b)
  (cond ((eq? b #t) #t)
	((eq? b #f) #t)
	(else #f)))

(define (caar p) (car (car p)))
(define (cadr p) (car (cdr p)))
(define (cdar p) (cdr (car p)))
(define (cddr p) (cdr (cdr p)))

(define map (lambda (fn p)
    (cond ((null p) nil)
           (t (cons (fn (car p)) (map fn (cdr p)))))))

(define let (special (varlist &rest)
    (cons (cons 'lambda (cons (map car varlist) &rest))
	  (map cadr varlist))))

(define listp (lambda (p)
    (cond ((null p) t)
	  ((consp p) t)
	  (t nil))))

(define zerop (lambda (n)
    (cond ((eq n 0) t)
	  (t nil))))

(define booleanp (lambda (b)
    (cond ((null b) t)
	  ((eq b t) t)
	  (t nil))))

(define begin (special (&rest)
    (list (cons 'lambda (cons nil &rest)))))

(define if (special (a b c)
    (cond (a b)
	  (t c))))

(define append (lambda (p q)
    (cond ((null p) (cond ((null q) nil)
                           (t (cons (car q) (append p (cdr q))))))
           (t (cons (car p) (append (cdr p) q))))))

(define unev-let (special (varlist &rest)
    (cons
	    (cons 'lambda (cons (map car varlist) &rest))
	    (map cadr varlist))))

(define and2 (special (&rest)
    (eval (unev-let ((andlis nil))
      (setq andlis (lambda (q)
	(cond ((null q) t)
	      ((null (car q)) nil)
	      ((null (cdr q)) (car q))
	      (t (andlis (cdr q))))))
      (andlis &rest)))))

(define and (special (&rest)
    (let ((andlis nil))
      (setq andlis (lambda (q)
	(cond ((null q) t)
	      ((null (car q)) nil)
	      ((null (cdr q)) (car q))
	      (t (andlis (cdr q))))))
      (andlis &rest))))

(define and3 (special (&rest)
    (define andlis (lambda (q)
	(cond ((null q) t)
	      ((null (car q)) nil)
	      ((null (cdr q)) (car q))
	      (t (andlis (cdr q))))))
    (andlis &rest)))

(define or (special (&rest)
    (eval (unev-let ((orlis nil))
      (setq orlis (lambda (q)
	(cond ((null q) nil)
	      ((not (null (car q))) (car q))
	      (t (orlis (cdr q))))))
      (orlis &rest)))))

(define <= (lambda (a &rest) 
    (eval (unev-let ((lesseq nil))
        (setq lesseq (lambda (a q)
            (cond ((null q) t)
		  ((eq a (car q)) (lesseq (car q) (cdr q)))
		  ((< a (car q)) (lesseq (car q) (cdr q)))
		  (t nil))))
        (lesseq a &rest)))))

(define >= (lambda (a &rest) 
    (eval (unev-let ((greatereq nil))
        (setq greatereq (lambda (a q)
            (cond ((null q) t)
		  ((eq a (car q)) (greatereq (car q) (cdr q)))
		  ((> a (car q)) (greatereq (car q) (cdr q)))
		  (t nil))))
        (greatereq a &rest)))))

(define inc (special (var)
    (eval (list 'setq var (list '+ 1 var)))))

(define set (lambda (x y)
    (eval (list 'setq x 'y))))

(define fact (lambda (n)
    (cond ((eq n 0) 1)
	  (t (* n (fact (- n 1)))))))

(define make-counter (lambda (value)
    (lambda () (setq value (+ value 1)))))

(define make-balance (lambda (balance)
    (lambda (amount) (setq balance (- balance amount)))))

(define sqrt2 (lambda (x)
    (let ((abs nil)
	  (average nil)
	  (square nil)
	  (good-enough? nil)
	  (improve nil)
	  (sqrt-iter nil))
      (setq abs (lambda (n) (cond ((< n 0) (- n)) (t n))))
      (setq average (lambda (x y) (/ (+ x y) 2)))
      (setq square (lambda (n) (* n n)))
      (setq good-enough? (lambda (guess)
			    (< (abs (- (square guess) x)) (/ 1 100))))
      (setq improve (lambda (guess) (average guess (/ x guess))))
      (setq sqrt-iter (lambda (guess)
			 (cond ((good-enough? guess) guess)
			       (t (sqrt-iter (improve guess))))))
      (sqrt-iter 1))))

(define sqrt (lambda (x)
    ((lambda (abs average square good-enough? improve sqr-iter)
       (setq abs (lambda (n) (cond ((< n 0) (- n)) (t n))))
       (setq average (lambda (x y) (/ (+ x y) 2)))
       (setq square (lambda (n) (* n n)))
       (setq good-enough? (lambda (guess)
			    (< (abs (- (square guess) x)) (/ 1 100))))
       (setq improve (lambda (guess) (average guess (/ x guess))))
       (setq sqrt-iter (lambda (guess)
			 (cond ((good-enough? guess) guess)
			       (t (sqrt-iter (improve guess))))))
       (sqrt-iter 1)) nil nil nil nil nil nil)))


(define cons3 (lambda (x y)
     (lambda (m)
	    (cond ((eq m 0) x)
		  ((eq m 1) y)
		  (t 'error)))))

(define cons2 (lambda (x y)
  (let ((dispatch nil))
    (setq dispatch (lambda (m)
			    (cond ((eq m 0) x)
				  ((eq m 1) y)
				  (t 'error))))
    dispatch)))

(define factorial (lambda (n) (fact-iter 1 1 n)))
(define fact-iter (lambda (p c m)
	(cond ((> c m) p)
	      (t (fact-iter (* c p) (+ c 1) m)))))

